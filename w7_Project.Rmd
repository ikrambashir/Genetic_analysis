---
title: "Project RIL Population Z015"
author: "Bashir,I. (2022)"
date: "21/04/2022"
output:
  pdf_document: default
  html_document: default
  word_document: default
editor_options:
  chunk_output_type: inline
---

## **Abstract** 

A molecular linkage map for the maize hybrid of cross between M162W and B73 was constructed by using 1106 SSR markers. The total map length was 1348.39 `cM`. Single marker analysis `(SMA)`, interval mapping `(IM)`, composite interval mapping `(CIM)` and multiple interval mapping `(MIM)` was used to identify the plant height (PH) based on the phenotypic data of 185 individuals of F2:3 families. Then 7 PH relevant QTL were identified. The mean contribution was 43.78% to total phenotypic variability confirmed by interval mapping. Composite interval mapping identifies 5 QTL present on chromosome 1, 4, 5 and 7. Which contribute 25.45% of total phenotypic variability. Furthermore, multiple interval mapping confirms 6 QTL present on chromosome 1, 4, 5, 7, 8 and 10 with no interaction effect.

## Introduction

you can explain the importance of the crop, the origin of the pop, the meaning of PH for maize and how the different `qtl` mapping approaches might help us to understand the better genetic basis of a trait and guide breeding decisions.

## Material and Methods:

### Linkage Map

#### Loading Data

```{r}
library(qtl)
maize <- read.cross(format="csv", file="data/population_Z015.csv", genotypes=c("0", "1", "2"), crosstype = "riself")
```

#### Data Summary

```{r}
summary(maize)
geno.image(maize)
```

#### Chi_squared tests for segregation distortion:

```{r}
gt.maize <- geno.table(maize)
gt.maize
head(gt.maize)
table(gt.maize$P.value <0.05)
table(gt.maize$P.value <0.05/totmar(maize))
```

#### Estimation of the pairwise or two-point recombination fractions:

```{r}
maize <- est.rf(cross = maize)
dim(maize$rf)
plotRF(maize, col.scheme = "redblue")
```

Again, this `heatmap` presents both the estimates (above diagonal) and LOD scores (below diagonal). The\
`heatmap` shows more blue, colder colors for non-linked markers (i.e. r $\approx$ 0.5 and low LOD), and more red, warmer colors for the linked markers (i.e. r $<$ 0.35 and high ). It can now see how many groups are formed by with these markers:

#### Marker grouping:

```{r}
maize <- formLinkageGroups(maize, max.rf=0.38, min.lod=6.25, reorgMarkers=TRUE)
summary(maize)
plotRF(maize, col.scheme = "redblue")
```

#### Marker Ordering:

is done by using Multidimensional Scale (MDS) from `MDSMap` implements the MDS algorithm, and `MAPpoly` has a nice wrapper function called `mds_mappoly`. This function only needs the recombination fraction matrix estimated by `R/qtl`, and it returns a new order that can be used by `switch.order()` `R/qtl` function to yield a newly ordered linkage group.\
First, `MAPpoly package` was installed and MDS algorithm used to build a chosen linkage group.

```{r}
#library(mappoly)
```

```{r}
#getMDSorder <- function(cross, chr){
#  markers <- match(names(cross$geno[[chr]]$map), colnames(cross$rf))
#  mat <- cross$rf[markers,markers]
#  rec.mat <- lod.mat <- matrix(rep(NA, length(markers)^2), nrow =length(markers))
#  colnames(rec.mat) <- colnames(lod.mat) <- rownames(rec.mat) <- rownames(lod.mat) <- colnames(mat)
#  lod.mat[upper.tri(lod.mat)] <- mat[upper.tri(mat)]
#  lod.mat[lower.tri(lod.mat)] <- t(lod.mat)[lower.tri(lod.mat)]
#  rec.mat[lower.tri(rec.mat)] <- mat[lower.tri(mat)]
#  rec.mat[upper.tri(rec.mat)] <- t(rec.mat)[upper.tri(rec.mat)]
#  input.mat <- NULL
#  input.mat$rec.mat <- rec.mat
#  input.mat$lod.mat <- lod.mat
#  mds.map <- mappoly::mds_mappoly(input.mat)
#  mds.ord <- match(as.character(mds.map$locimap$locus), colnames(mat))
#  return(mds.ord)
#}
```

We'll create a new object called `maize.mds` which is a copy of our original cross object maize , so that we can update the ordering within `maize.mds` only. In addition, we'll create an empty object called `loglik.mds` to store the log-likelihood of the orderings obtained using MDS:

```{r}
#maize.mds <- maize
#loglik.mds <- c()
```

#### Reordering markers into each of the 10 linkage groups:

```{r}
#for(c in 1:10) {
#  mds.ord <- getMDSorder(cross = maize.mds, chr = c)
#  maize.mds <- switch.order(cross = maize.mds, chr=c, order=mds.ord)
#  plotRF(maize.mds, chr=c, col.scheme = "redblue")
#  print(pull.map(maize.mds, chr = c))
#  print(loglik.mds[c] <- attr(maize.mds$geno[[c]]$map, "loglik"))
#}
```

#### Final map:

```{r}
#knitr::kable(cbind(summaryMap(maize.mds), log.likelihood=c(loglik.mds, sum(loglik.mds))))
```

```{r}
#plotMap(maize.mds)
```

```{r}
#plotRF(maize.mds, col.scheme = "redblue")
```

```{r}
#save.image("maize_mds.Rdata")
```

```{r}
load("maize_mds.RData")
```

```{r}
summaryMap(maize.mds)
```

```{r}
plotMap(maize.mds)
```

```{r}
plotRF(maize.mds, col.scheme = "redblue")
```

## QTL Mapping

Used the linkage map to perform interval mapping (IM) for the trait "PlantHeight". Do not forget to run permutation tests to identify the LOD threshold to declare QTL at an alpha level of 0.05. Results for the QTL peak within each QTL region should be presented as a table showing QTL chromosome and location of its peak, their effects, associated LOD scores, and R-squared.

Approximate critical values previously obtained from permutation tests (idealy, should be run separatly for each population):

#### Single marker analysis (SMA)

```{r}
maize.mr <- scanone(maize.mds, pheno.col = "PlantHeight", method = "mr")
plot(maize.mr, type = "p", main = "Single marker analysis (SMA)")
summary(maize.mr)
maize.perm.mr <- scanone(cross = maize.mds, pheno.col = "PlantHeight", method = "mr", 
                         n.perm = 1000, verbose = FALSE, n.cluster = 2)
lod.sma <- summary(maize.perm.mr, alpha = 0.05)
```

```{r}
plot(maize.mr, type = "p", main = "Single marker analysis (SMA)") +abline(h = lod.sma)
maize.mr.sig <- summary(maize.mr, perms = maize.perm.mr, alpha = 0.05)
maize.mr.sig
```

#### Interval mapping (IM)

```{r}
maize.mds <- calc.genoprob(cross = maize.mds, step = 1)
maize.im <- scanone(cross = maize.mds, pheno.col = "PlantHeight", method = "hk")
summary(maize.im)
```

```{r}
#perm.im <- scanone(cross = maize.mds, pheno.col = "PlantHeight", method = "hk", n.perm = 1000, n.cluster = 2)
#save(perm.im, file = "perm.im.RData")
load("perm.im.RData")
lod.im <- summary(perm.im, alpha = 0.05)
plot(maize.im, col = "red", main = "Interval mapping (IM)")+abline(h= lod.im)
```

Notice we can use `maize.im.sig` to extract the chromosomes ( chr ) and positions ( pos ) of our significant QTL:

Finally, the `makeqtl()` and `fitqtl()` are used to show the QTL effect estimates for an RIL population based on an object derived from the function `sim.geno()` :

We can also build a multiple QTL model, including all three QTL:

```{r}
maize.im.sig <- summary(maize.im, perms = perm.im, alpha = 0.05)
maize.im.sig
chr <- maize.im.sig$chr
chr
pos <- maize.im.sig$pos
pos
```

```{r}
maize.mds <- sim.geno(cross = maize.mds, step = 1)
maize.im.qtl <- makeqtl(cross = maize.mds, chr = chr, pos = pos)
maize.im.qtl
```

```{r}
formula.im <- as.formula(paste("y", paste0("Q", c(1:length(maize.im.sig$pos)), 
                                        collapse = "+"), sep = " ~ "))
maize.im.fit <- fitqtl(cross = maize.mds, pheno.col = "PlantHeight", 
                        qtl = maize.im.qtl, formula = formula.im, get.ests = TRUE)
summary(maize.im.fit)
```

```{r}
#save.image(("maize_im.RData"))
```

#### **Composite interval mapping (CIM)**

```{r, warning = FALSE}
perm.cim <- 7.4
#maize.cim10 <- cim(cross = maize.mds, pheno.col = "PlantHeight", method = "hk",n.marcovar = 2 * sqrt(nind(maize.mds)), window = 10)
#save(maize.cim10, file = "maize.cim10.RData")
load("maize.cim10.RData")
summary(maize.cim10)
summary(maize.cim10, threshold = perm.cim)
```

```{r}
#maize.cim15 <- cim(cross = maize.mds, pheno.col = "PlantHeight", method = "hk", n.marcovar = 2 * sqrt(nind(maize.mds)), window = 15)
#save(maize.cim15, file = "maize.cim15.RData")
load("maize.cim15.RData")
summary(maize.cim15)
summary(maize.cim15, threshold = perm.cim)
```

```{r}
#maize.cim20 <- cim(cross = maize.mds, pheno.col = "PlantHeight", method = "hk", n.marcovar = 2 * sqrt(nind(maize.mds)), window = 20)
#save(maize.cim20, file = "maize.cim20.RData")
load("maize.cim20.RData")
summary(maize.cim20)
summary(maize.cim20, threshold = perm.cim)
```

```{r}
#maize.cimInf <- cim(cross = maize.mds, pheno.col = "PlantHeight", method = "hk", n.marcovar = 2 * sqrt(nind(maize.mds)), window = Inf)
#save(maize.cimInf, file = "maize.cimInf.RData")
load("maize.cimInf.RData")
summary(maize.cimInf)
summary(maize.cimInf, threshold = perm.cim)
```

The green dots represent the location of markers selected as covariates (cofactors) for the CIM search with window = `Inf.`\
Noticed that the QTL on chromosome 1 and 3 that we had identified using IM is right below the threshold for the CIM analysis - so we called them suggestive QTL here. Depending on the researcher's decision, we could low the threshold a bit to include it as a QTL using CIM, which is probably okay. We'll see, however, a better way to deal with it when running a multiple-QTL model, which is our next topic.

Right now, suppose we want to investigate the QTL estimates under CIM with window = 10 . We just need to store the QTL chromosomes and positions from our selected model (CIM with)

However, we noticed that only one QTL on chromosome 1 is listed (the one with the highest LOD score). We need to find the other one by looking at the positions in that chromosome that have a LOD score greater than our threshold of 7.39:

```{r}
plot(maize.cim10, maize.cim15, maize.cimInf, col = c("blue", "orange", "cyan"), main = "Composite interval mapping (CIM)")+abline(h=perm.cim)
```

```{r}
maize.cim.sig <- summary(maize.cim10, threshold = perm.cim)
maize.cim.sig
```

```{r}
peak.markers <- which(maize.cim10$lod[maize.cim10$chr == 1] > 7.4)
maize.cim10$lod[peak.markers]
maize.cim10$pos[peak.markers]
chr <- c(1, maize.cim.sig$chr)
pos <- c(124, maize.cim.sig$pos)
chr
pos
```

In order to show the QTL effect estimates for an RIL population, we need to use the function `sim.geno()`, then `makeqtl()` and `fitqtl()` :

```{r}
maize.mds <- sim.geno(maize.mds, step = 1)
maize.cim.qtl <- makeqtl(cross = maize.mds, chr = chr, pos = pos)
maize.cim.qtl
plot(maize.cim.qtl)
```

```{r}
formula <- as.formula(paste("y", paste0("Q", c(1:length(maize.cim.sig$pos)), 
                                        collapse = "+"), sep = " ~ "))
maize.cim.fit <- fitqtl(cross = maize.mds, pheno.col = "PlantHeight", 
                        qtl = maize.cim.qtl, formula = formula, get.ests = TRUE)
summary(maize.cim.fit)
```

```{r}
maize.ref <- refineqtl(cross = maize.mds, pheno.col = "PlantHeight", qtl = maize.cim.qtl, formula =  formula)
plotLodProfile(maize.ref)
```

#### Multiple Interval Mapping (MIM)

```{r}
#perm.mim <- scantwo(maize.mds, pheno.col = "PlantHeight", method = "hk", n.perm = 1000, n.cluster = 2)
#save(perm.mim, file = "perm.mim.RData")
load("perm.mim.RData")
threshold.mim <- summary(perm.mim, alpha = 0.05)
threshold.mim
penalties <- calc.penalties(perm.mim)
penalties
```

#### Main effect

```{r}
maize.step <- stepwiseqtl(maize.mds, pheno.col = "PlantHeight", max.qtl = 6, method = "hk", penalties = penalties)
summary(maize.step)
plotLodProfile(maize.step, main ="PlantHeight")
```

```{r}
#maize.mds <- calc.genoprob(maize.mds, step = 2)
#maize.two <- scantwo(maize.mds, pheno.col = "PlantHeight", method = "hk", n.cluster = 2)
#save(maize.two, file = "maize.two.RData")
```

```{r fig.height=6, fig.width=6}
load("maize.two.RData")
plot(maize.two, col.scheme = "redblue")
summary(maize.two)
```

## Discussion

## Conclusion

## References
